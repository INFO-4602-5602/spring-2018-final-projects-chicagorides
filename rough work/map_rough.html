<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8' />
  <title>Animate a line</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
  <script src="http://d3js.org/d3.v3.min.js" type="text/javascript"></script>
  <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.2/mapbox-gl.js'></script>
  <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.44.2/mapbox-gl.css' rel='stylesheet' />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" integrity="sha512-Rksm5RenBEKSKFjgI3a41vrjkw4EVPlJ3+OiI65vTjIdo9brlAacEuKOiQ5OFh7cOI1bkDwLqdLw3Zg0cRJAAQ==" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js" integrity="sha512-/Nsx9X4HebavoBvEBuyp3I7od5tA0UzAxs+j83KgC8PU0kgB4XiK4Lfe4y4cgBtaRJQEIFCW+oC506aPT2L1zw==" crossorigin=""></script>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<!-- Google maps api -->

  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }

    svg {
      position: relative;
    }

    path {
      fill: yellow;
      stroke-width: 2px;
      stroke: red;
      stroke-opacity: 1;
    }

    .travelMarker {
      fill: yellow;
      opacity: 0.75;
    }

    .waypoints {
      fill: black;
      opacity: 0;
    }

    }

    .drinks {
      stroke: black;
      fill: red;
    }

    .lineConnect {
      fill: none;
      stroke: black;
      opacity: 1;
    }

    .locnames {
      fill: black;
      text-shadow: 1px 1px 1px #FFF, 3px 3px 5px #000;
      font-weight: bold;
      font-size: 13px;
    }
  </style>
</head>

<body>

  <!-- <style>
button {
    position: absolute;
    margin: 20px;
}

#pause::after {
    content: 'Pause';
}

#pause.pause::after {
    content: 'Play';
}
</style> -->
  <div id='map'></div>

  <script>
    // L.mapbox.accessToken = "pk.eyJ1IjoiYXNod2luc2Fua2FyIiwiYSI6ImNqZ2xmcmFwMDFvMHQzMXJ6NXJ6MWFvY2MifQ.RFGwkW7_ilq_QTWjXjl3Lw";

    var mapboxTiles = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ'
    });
    var map = L.map('map')
      .addLayer(mapboxTiles)
      .setView([40.72332345541449, -73.99], 14); //chicago : 41.8781,-87.6298

    // L.mapbox.styleLayer('mapbox://styles/mapbox/light-v9').addTo(map);

    function initMap() {

    var chicago_center = {lat: 41.85, lng: -87.65};
    var new_york = {lat:40.72332345541449,lng: -73.99};

    d3.csv('../data/jan.csv', function(error, data) {

    console.log("Loaded January Data ");


    var point_a = {lat: 41.85, lng: -73.99316};
    var point_b = {lat: 40.72519, lng: -73.99215};

    var request = {
      destination: point_a,
      origin: point_b,
      travelMode: 'DRIVING'
    };

    var directionsService = new google.maps.DirectionsService();
    directionsService.route(request, function(response, status) {
      if (status == 'OK') {
        // Display the route on the map.
        console.log(response);
      }
    });

      });
  }


  var svg = d3.select(map.getPanes().overlayPane).append("svg");
  // if you don't include the leaflet-zoom-hide when a
  // user zooms in or out you will still see the phantom
  // original SVG
  var g = svg.append("g").attr("class", "leaflet-zoom-hide");

    d3.json("points.json", function(collection) {
      // console.log(collection);
      // this is not needed right now, but for future we may need
      // to implement some filtering. This uses the d3 filter function
      // featuresdata is an array of point objects
      var featuresdata = collection.features.filter(function(d) {
        return d.properties.id == "route1"
      })
      //stream transform. transforms geometry before passing it to
      // listener. Can be used in conjunction with d3.geo.path
      // to implement the transform.
      var transform = d3.geo.transform({
        point: projectPoint
      });
      //d3.geo.path translates GeoJSON to SVG path codes.
      //essentially a path generator. In this case it's
      // a path generator referencing our custom "projection"
      // which is the Leaflet method latLngToLayerPoint inside
      // our function called projectPoint
      var d3path = d3.geo.path().projection(transform);
      // Here we're creating a FUNCTION to generate a line
      // from input points. Since input points will be in
      // Lat/Long they need to be converted to map units
      // with applyLatLngToLayer
      var toLine = d3.svg.line()
        .interpolate("linear")
        .x(function(d) {
          return applyLatLngToLayer(d).x
        })
        .y(function(d) {
          return applyLatLngToLayer(d).y
        });
      // From now on we are essentially appending our features to the
      // group element. We're adding a class with the line name
      // and we're making them invisible
      // these are the points that make up the path
      // they are unnecessary so I've make them
      // transparent for now
      var ptFeatures = g.selectAll("circle")
        .data(featuresdata)
        .enter()
        .append("circle")
        .attr("r", 3)
        .attr("class", "waypoints");
      // Here we will make the points into a single
      // line/path. Note that we surround the featuresdata
      // with [] to tell d3 to treat all the points as a
      // single line. For now these are basically points
      // but below we set the "d" attribute using the
      // line creator function from above.
      var linePath = g.selectAll(".lineConnect")
        .data([featuresdata])
        .enter()
        .append("path")
        .attr("class", "lineConnect");
      // This will be our traveling circle it will
      // travel along our path
      var marker = g.append("circle")
        .attr("r", 10)
        .attr("id", "marker")
        .attr("class", "travelMarker");
      // For simplicity I hard-coded this! I'm taking
      // the first and the last object (the origin)
      // and destination and adding them separately to
      // better style them. There is probably a better
      // way to do this!
      var originANDdestination = [featuresdata[0], featuresdata[17]]
      var begend = g.selectAll(".drinks")
        .data(originANDdestination)
        .enter()
        .append("circle", ".drinks")
        .attr("r", 5)
        .style("fill", "red")
        .style("opacity", "1");
      // I want names for my coffee and beer
      var text = g.selectAll("text")
        .data(originANDdestination)
        .enter()
        .append("text")
        .text(function(d) {
          return d.properties.name
        })
        .attr("class", "locnames")
        .attr("y", function(d) {
          return -10
        })
      // when the user zooms in or out you need to reset
      // the view
      map.on("viewreset", reset);
      // this puts stuff on the map!
      reset();
      transition();
      // Reposition the SVG to cover the features.
      function reset() {
        var bounds = d3path.bounds(collection),
          topLeft = bounds[0],
          bottomRight = bounds[1];
        // here you're setting some styles, width, heigh etc
        // to the SVG. Note that we're adding a little height and
        // width because otherwise the bounding box would perfectly
        // cover our features BUT... since you might be using a big
        // circle to represent a 1 dimensional point, the circle
        // might get cut off.
        text.attr("transform",
          function(d) {
            return "translate(" +
              applyLatLngToLayer(d).x + "," +
              applyLatLngToLayer(d).y + ")";
          });
        // for the points we need to convert from latlong
        // to map units
        begend.attr("transform",
          function(d) {
            return "translate(" +
              applyLatLngToLayer(d).x + "," +
              applyLatLngToLayer(d).y + ")";
          });
        ptFeatures.attr("transform",
          function(d) {
            return "translate(" +
              applyLatLngToLayer(d).x + "," +
              applyLatLngToLayer(d).y + ")";
          });
        // again, not best practice, but I'm harding coding
        // the starting point
        marker.attr("transform",
          function() {
            var y = featuresdata[0].geometry.coordinates[1]
            var x = featuresdata[0].geometry.coordinates[0]
            return "translate(" +
              map.latLngToLayerPoint(new L.LatLng(y, x)).x + "," +
              map.latLngToLayerPoint(new L.LatLng(y, x)).y + ")";
          });
        // Setting the size and location of the overall SVG container
        svg.attr("width", bottomRight[0] - topLeft[0] + 120)
          .attr("height", bottomRight[1] - topLeft[1] + 120)
          .style("left", topLeft[0] - 50 + "px")
          .style("top", topLeft[1] - 50 + "px");
        // linePath.attr("d", d3path);
        linePath.attr("d", toLine)
        // ptPath.attr("d", d3path);
        g.attr("transform", "translate(" + (-topLeft[0] + 50) + "," + (-topLeft[1] + 50) + ")");
      } // end reset
      // the transition function could have been done above using
      // chaining but it's cleaner to have a separate function.
      // the transition. Dash array expects "500, 30" where
      // 500 is the length of the "dash" 30 is the length of the
      // gap. So if you had a line that is 500 long and you used
      // "500, 0" you would have a solid line. If you had "500,500"
      // you would have a 500px line followed by a 500px gap. This
      // can be manipulated by starting with a complete gap "0,500"
      // then a small line "1,500" then bigger line "2,500" and so
      // on. The values themselves ("0,500", "1,500" etc) are being
      // fed to the attrTween operator
      function transition() {
        linePath.transition()
          .duration(7500)
          .attrTween("stroke-dasharray", tweenDash)
          .each("end", function() {
            d3.select(this).call(transition); // infinite loop
          });
      } //end transition
      // this function feeds the attrTween operator above with the
      // stroke and dash lengths
      function tweenDash() {

    return function(t) {
        // In original version of this post the next two lines of JS were
        // outside this return which led to odd behavior on zoom
        // Thanks to Martin Raifer for the suggested fix.

        //total length of path (single value)
        var l = linePath.node().getTotalLength();
        interpolate = d3.interpolateString("0," + l, l + "," + l);

        //t is fraction of time 0-1 since transition began
        var marker = d3.select("#marker");

        // p is the point on the line (coordinates) at a given length
        // along the line. In this case if l=50 and we're midway through
        // the time then this would 25.
        var p = linePath.node().getPointAtLength(t * l);

        //Move the marker to that point
        marker.attr("transform", "translate(" + p.x + "," + p.y + ")"); //move marker
        return interpolate(t);
    }
}
 //end tweenDash
      // Use Leaflet to implement a D3 geometric transformation.
      // the latLngToLayerPoint is a Leaflet conversion method:
      //Returns the map layer point that corresponds to the given geographical
      // coordinates (useful for placing overlays on the map).
      function projectPoint(x, y) {
        var point = map.latLngToLayerPoint(new L.LatLng(y, x));
        this.stream.point(point.x, point.y);
      } //end projectPoint
    });
    // similar to projectPoint this function converts lat/long to
    // svg coordinates except that it accepts a point from our
    // GeoJSON
    function applyLatLngToLayer(d) {
      var y = d.geometry.coordinates[1]
      var x = d.geometry.coordinates[0]
      return map.latLngToLayerPoint(new L.LatLng(y, x))
    }

  </script>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBuOXxPJIQca_M3jM_tKj7DvLY6UM0vcH0&callback=initMap"
      async defer></script>

</body>

</html>
